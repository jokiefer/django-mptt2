{% load i18n mptt_admin %}
{% if result_hidden_fields %}
<div class="hiddenfields">{# DIV for HTML validation #}
    {% for item in result_hidden_fields %}{{ item }}{% endfor %}
</div>
{% endif %}

{% draggable_tree cl.result_list %}

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
    integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/@mdi/font@7.2.96/css/materialdesignicons.min.css" rel="stylesheet">
<script src=" https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js "></script>

<script>

    var trees = [].slice.call(document.querySelectorAll('[id*="tree-id"]'));

    trees.forEach((tree) => {
        var nestedSortables = [].slice.call(tree.querySelectorAll('.nested-sortable'));
        // Loop through each nested sortable element

        nestedSortables.forEach((nested) => {
            new Sortable(nested, {
                group: tree.id, // is the id of the sourounding html container. Should be the tree id to allow only dragging nodes inside current tree
                animation: 150,
                fallbackOnBody: true,
                swapThreshold: 0.25,

                // Element dragging ended
                onEnd: function (/**Event*/evt) {
                    if (evt.newIndex == 0) {
                        // first child of dataset.targetId
                        console.log("first child of ", evt.to.dataset.targetId);
                    } else if (evt.newIndex == evt.to.children.length - 1) {
                        // last child of dataset.targetId
                        console.log("last child of ", evt.to.dataset.targetId);
                    } else {
                        const leftSibling = evt.to.children[evt.newIndex - 1]
                        console.log("right of ", leftSibling.dataset.nodeId);
                    }
                },
            });
        });
    });

</script>